// File generated from our OpenAPI spec by Stainless.

package ai.nextbillion.models.fleetify.routes

import ai.nextbillion.core.Enum
import ai.nextbillion.core.ExcludeMissing
import ai.nextbillion.core.JsonField
import ai.nextbillion.core.JsonMissing
import ai.nextbillion.core.JsonValue
import ai.nextbillion.core.Params
import ai.nextbillion.core.checkKnown
import ai.nextbillion.core.checkRequired
import ai.nextbillion.core.http.Headers
import ai.nextbillion.core.http.QueryParams
import ai.nextbillion.core.toImmutable
import ai.nextbillion.errors.NextbillionSdkInvalidDataException
import ai.nextbillion.models.fleetify.routes.steps.RouteStepsRequest
import com.fasterxml.jackson.annotation.JsonAnyGetter
import com.fasterxml.jackson.annotation.JsonAnySetter
import com.fasterxml.jackson.annotation.JsonCreator
import com.fasterxml.jackson.annotation.JsonProperty
import java.util.Collections
import java.util.Objects
import java.util.Optional
import kotlin.jvm.optionals.getOrNull

/** Dispatch a new route */
class RouteCreateParams
private constructor(
    private val key: String,
    private val body: Body,
    private val additionalHeaders: Headers,
    private val additionalQueryParams: QueryParams,
) : Params {

    /** A key is a unique identifier that is required to authenticate a request to the API. */
    fun key(): String = key

    /**
     * Specify the e-mail address of the driver who should receive the route. The e-mail address
     * must be registered in [NextBillion.ai Cloud Console](https://console.nextbillion.ai/).
     *
     * @throws NextbillionSdkInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun driverEmail(): String = body.driverEmail()

    /**
     * An array of objects to collect the details about the intermediate steps in the route to be
     * dispatched. Each object corresponds to a single step. The array must begin with a start-type
     * step and end with an end-type step, to form a valid route.
     *
     * @throws NextbillionSdkInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun steps(): List<RouteStepsRequest> = body.steps()

    /**
     * Specify the total distance, in meters, for an informative display in Driver's app. The
     * distance specified here has no effect on the actual route that the service generates.
     *
     * @throws NextbillionSdkInvalidDataException if the JSON field has an unexpected type (e.g. if
     *   the server responded with an unexpected value).
     */
    fun distance(): Optional<Long> = body.distance()

    /**
     * Specify the ID of the document template that should be used to collect proof of completion
     * for all steps in the route. In order to complete each route step, the driver will need to
     * submit a form generated by the rules defined in the given document template. Use the
     * [Documents API](https://docs.nextbillion.ai/docs/dispatches/documents-api) to create, read
     * and manage document templates.
     *
     * Please note that the document template ID assigned to a route does not apply to following
     * step types - start, end, break, layover.
     *
     * @throws NextbillionSdkInvalidDataException if the JSON field has an unexpected type (e.g. if
     *   the server responded with an unexpected value).
     */
    fun documentTemplateId(): Optional<String> = body.documentTemplateId()

    /**
     * Specify the Route Optimization request ID. When this ID is provided, all other fields will be
     * ignored (including the required fields) and the route optimization result will be used to
     * form the routes and corresponding steps.
     *
     * Please note that:
     * - The driver's email ID must be provided in input vehicle.metadata as user_email such that
     *   the route optimization result must contain a valid driver email, step's arrival time, etc.,
     *   to make a successful dispatch.
     * - Document Template for collecting proof of delivery or completion can not be specified when
     *   using this field to dispatch a route.
     * - In case of an error at any part among the routes, the API will immediately return the error
     *   with the index of the specific route or route step.
     * - On a successful dispatch, the API returns the last route, if there are many, in the
     *   response payload.
     *
     * @throws NextbillionSdkInvalidDataException if the JSON field has an unexpected type (e.g. if
     *   the server responded with an unexpected value).
     */
    fun roRequestId(): Optional<String> = body.roRequestId()

    /**
     * The routing object allows defining the routing characteristics that should be used to
     * generate a route when the Driver uses the in-app navigation. Only car mode is supported
     * currently.
     *
     * @throws NextbillionSdkInvalidDataException if the JSON field has an unexpected type (e.g. if
     *   the server responded with an unexpected value).
     */
    fun routing(): Optional<Routing> = body.routing()

    /**
     * Returns the raw JSON value of [driverEmail].
     *
     * Unlike [driverEmail], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _driverEmail(): JsonField<String> = body._driverEmail()

    /**
     * Returns the raw JSON value of [steps].
     *
     * Unlike [steps], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _steps(): JsonField<List<RouteStepsRequest>> = body._steps()

    /**
     * Returns the raw JSON value of [distance].
     *
     * Unlike [distance], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _distance(): JsonField<Long> = body._distance()

    /**
     * Returns the raw JSON value of [documentTemplateId].
     *
     * Unlike [documentTemplateId], this method doesn't throw if the JSON field has an unexpected
     * type.
     */
    fun _documentTemplateId(): JsonField<String> = body._documentTemplateId()

    /**
     * Returns the raw JSON value of [roRequestId].
     *
     * Unlike [roRequestId], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _roRequestId(): JsonField<String> = body._roRequestId()

    /**
     * Returns the raw JSON value of [routing].
     *
     * Unlike [routing], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _routing(): JsonField<Routing> = body._routing()

    fun _additionalBodyProperties(): Map<String, JsonValue> = body._additionalProperties()

    /** Additional headers to send with the request. */
    fun _additionalHeaders(): Headers = additionalHeaders

    /** Additional query param to send with the request. */
    fun _additionalQueryParams(): QueryParams = additionalQueryParams

    fun toBuilder() = Builder().from(this)

    companion object {

        /**
         * Returns a mutable builder for constructing an instance of [RouteCreateParams].
         *
         * The following fields are required:
         * ```java
         * .key()
         * .driverEmail()
         * .steps()
         * ```
         */
        @JvmStatic fun builder() = Builder()
    }

    /** A builder for [RouteCreateParams]. */
    class Builder internal constructor() {

        private var key: String? = null
        private var body: Body.Builder = Body.builder()
        private var additionalHeaders: Headers.Builder = Headers.builder()
        private var additionalQueryParams: QueryParams.Builder = QueryParams.builder()

        @JvmSynthetic
        internal fun from(routeCreateParams: RouteCreateParams) = apply {
            key = routeCreateParams.key
            body = routeCreateParams.body.toBuilder()
            additionalHeaders = routeCreateParams.additionalHeaders.toBuilder()
            additionalQueryParams = routeCreateParams.additionalQueryParams.toBuilder()
        }

        /** A key is a unique identifier that is required to authenticate a request to the API. */
        fun key(key: String) = apply { this.key = key }

        /**
         * Sets the entire request body.
         *
         * This is generally only useful if you are already constructing the body separately.
         * Otherwise, it's more convenient to use the top-level setters instead:
         * - [driverEmail]
         * - [steps]
         * - [distance]
         * - [documentTemplateId]
         * - [roRequestId]
         * - etc.
         */
        fun body(body: Body) = apply { this.body = body.toBuilder() }

        /**
         * Specify the e-mail address of the driver who should receive the route. The e-mail address
         * must be registered in [NextBillion.ai Cloud Console](https://console.nextbillion.ai/).
         */
        fun driverEmail(driverEmail: String) = apply { body.driverEmail(driverEmail) }

        /**
         * Sets [Builder.driverEmail] to an arbitrary JSON value.
         *
         * You should usually call [Builder.driverEmail] with a well-typed [String] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun driverEmail(driverEmail: JsonField<String>) = apply { body.driverEmail(driverEmail) }

        /**
         * An array of objects to collect the details about the intermediate steps in the route to
         * be dispatched. Each object corresponds to a single step. The array must begin with a
         * start-type step and end with an end-type step, to form a valid route.
         */
        fun steps(steps: List<RouteStepsRequest>) = apply { body.steps(steps) }

        /**
         * Sets [Builder.steps] to an arbitrary JSON value.
         *
         * You should usually call [Builder.steps] with a well-typed `List<RouteStepsRequest>` value
         * instead. This method is primarily for setting the field to an undocumented or not yet
         * supported value.
         */
        fun steps(steps: JsonField<List<RouteStepsRequest>>) = apply { body.steps(steps) }

        /**
         * Adds a single [RouteStepsRequest] to [steps].
         *
         * @throws IllegalStateException if the field was previously set to a non-list.
         */
        fun addStep(step: RouteStepsRequest) = apply { body.addStep(step) }

        /**
         * Specify the total distance, in meters, for an informative display in Driver's app. The
         * distance specified here has no effect on the actual route that the service generates.
         */
        fun distance(distance: Long) = apply { body.distance(distance) }

        /**
         * Sets [Builder.distance] to an arbitrary JSON value.
         *
         * You should usually call [Builder.distance] with a well-typed [Long] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun distance(distance: JsonField<Long>) = apply { body.distance(distance) }

        /**
         * Specify the ID of the document template that should be used to collect proof of
         * completion for all steps in the route. In order to complete each route step, the driver
         * will need to submit a form generated by the rules defined in the given document template.
         * Use the [Documents API](https://docs.nextbillion.ai/docs/dispatches/documents-api) to
         * create, read and manage document templates.
         *
         * Please note that the document template ID assigned to a route does not apply to following
         * step types - start, end, break, layover.
         */
        fun documentTemplateId(documentTemplateId: String) = apply {
            body.documentTemplateId(documentTemplateId)
        }

        /**
         * Sets [Builder.documentTemplateId] to an arbitrary JSON value.
         *
         * You should usually call [Builder.documentTemplateId] with a well-typed [String] value
         * instead. This method is primarily for setting the field to an undocumented or not yet
         * supported value.
         */
        fun documentTemplateId(documentTemplateId: JsonField<String>) = apply {
            body.documentTemplateId(documentTemplateId)
        }

        /**
         * Specify the Route Optimization request ID. When this ID is provided, all other fields
         * will be ignored (including the required fields) and the route optimization result will be
         * used to form the routes and corresponding steps.
         *
         * Please note that:
         * - The driver's email ID must be provided in input vehicle.metadata as user_email such
         *   that the route optimization result must contain a valid driver email, step's arrival
         *   time, etc., to make a successful dispatch.
         * - Document Template for collecting proof of delivery or completion can not be specified
         *   when using this field to dispatch a route.
         * - In case of an error at any part among the routes, the API will immediately return the
         *   error with the index of the specific route or route step.
         * - On a successful dispatch, the API returns the last route, if there are many, in the
         *   response payload.
         */
        fun roRequestId(roRequestId: String) = apply { body.roRequestId(roRequestId) }

        /**
         * Sets [Builder.roRequestId] to an arbitrary JSON value.
         *
         * You should usually call [Builder.roRequestId] with a well-typed [String] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun roRequestId(roRequestId: JsonField<String>) = apply { body.roRequestId(roRequestId) }

        /**
         * The routing object allows defining the routing characteristics that should be used to
         * generate a route when the Driver uses the in-app navigation. Only car mode is supported
         * currently.
         */
        fun routing(routing: Routing) = apply { body.routing(routing) }

        /**
         * Sets [Builder.routing] to an arbitrary JSON value.
         *
         * You should usually call [Builder.routing] with a well-typed [Routing] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun routing(routing: JsonField<Routing>) = apply { body.routing(routing) }

        fun additionalBodyProperties(additionalBodyProperties: Map<String, JsonValue>) = apply {
            body.additionalProperties(additionalBodyProperties)
        }

        fun putAdditionalBodyProperty(key: String, value: JsonValue) = apply {
            body.putAdditionalProperty(key, value)
        }

        fun putAllAdditionalBodyProperties(additionalBodyProperties: Map<String, JsonValue>) =
            apply {
                body.putAllAdditionalProperties(additionalBodyProperties)
            }

        fun removeAdditionalBodyProperty(key: String) = apply { body.removeAdditionalProperty(key) }

        fun removeAllAdditionalBodyProperties(keys: Set<String>) = apply {
            body.removeAllAdditionalProperties(keys)
        }

        fun additionalHeaders(additionalHeaders: Headers) = apply {
            this.additionalHeaders.clear()
            putAllAdditionalHeaders(additionalHeaders)
        }

        fun additionalHeaders(additionalHeaders: Map<String, Iterable<String>>) = apply {
            this.additionalHeaders.clear()
            putAllAdditionalHeaders(additionalHeaders)
        }

        fun putAdditionalHeader(name: String, value: String) = apply {
            additionalHeaders.put(name, value)
        }

        fun putAdditionalHeaders(name: String, values: Iterable<String>) = apply {
            additionalHeaders.put(name, values)
        }

        fun putAllAdditionalHeaders(additionalHeaders: Headers) = apply {
            this.additionalHeaders.putAll(additionalHeaders)
        }

        fun putAllAdditionalHeaders(additionalHeaders: Map<String, Iterable<String>>) = apply {
            this.additionalHeaders.putAll(additionalHeaders)
        }

        fun replaceAdditionalHeaders(name: String, value: String) = apply {
            additionalHeaders.replace(name, value)
        }

        fun replaceAdditionalHeaders(name: String, values: Iterable<String>) = apply {
            additionalHeaders.replace(name, values)
        }

        fun replaceAllAdditionalHeaders(additionalHeaders: Headers) = apply {
            this.additionalHeaders.replaceAll(additionalHeaders)
        }

        fun replaceAllAdditionalHeaders(additionalHeaders: Map<String, Iterable<String>>) = apply {
            this.additionalHeaders.replaceAll(additionalHeaders)
        }

        fun removeAdditionalHeaders(name: String) = apply { additionalHeaders.remove(name) }

        fun removeAllAdditionalHeaders(names: Set<String>) = apply {
            additionalHeaders.removeAll(names)
        }

        fun additionalQueryParams(additionalQueryParams: QueryParams) = apply {
            this.additionalQueryParams.clear()
            putAllAdditionalQueryParams(additionalQueryParams)
        }

        fun additionalQueryParams(additionalQueryParams: Map<String, Iterable<String>>) = apply {
            this.additionalQueryParams.clear()
            putAllAdditionalQueryParams(additionalQueryParams)
        }

        fun putAdditionalQueryParam(key: String, value: String) = apply {
            additionalQueryParams.put(key, value)
        }

        fun putAdditionalQueryParams(key: String, values: Iterable<String>) = apply {
            additionalQueryParams.put(key, values)
        }

        fun putAllAdditionalQueryParams(additionalQueryParams: QueryParams) = apply {
            this.additionalQueryParams.putAll(additionalQueryParams)
        }

        fun putAllAdditionalQueryParams(additionalQueryParams: Map<String, Iterable<String>>) =
            apply {
                this.additionalQueryParams.putAll(additionalQueryParams)
            }

        fun replaceAdditionalQueryParams(key: String, value: String) = apply {
            additionalQueryParams.replace(key, value)
        }

        fun replaceAdditionalQueryParams(key: String, values: Iterable<String>) = apply {
            additionalQueryParams.replace(key, values)
        }

        fun replaceAllAdditionalQueryParams(additionalQueryParams: QueryParams) = apply {
            this.additionalQueryParams.replaceAll(additionalQueryParams)
        }

        fun replaceAllAdditionalQueryParams(additionalQueryParams: Map<String, Iterable<String>>) =
            apply {
                this.additionalQueryParams.replaceAll(additionalQueryParams)
            }

        fun removeAdditionalQueryParams(key: String) = apply { additionalQueryParams.remove(key) }

        fun removeAllAdditionalQueryParams(keys: Set<String>) = apply {
            additionalQueryParams.removeAll(keys)
        }

        /**
         * Returns an immutable instance of [RouteCreateParams].
         *
         * Further updates to this [Builder] will not mutate the returned instance.
         *
         * The following fields are required:
         * ```java
         * .key()
         * .driverEmail()
         * .steps()
         * ```
         *
         * @throws IllegalStateException if any required field is unset.
         */
        fun build(): RouteCreateParams =
            RouteCreateParams(
                checkRequired("key", key),
                body.build(),
                additionalHeaders.build(),
                additionalQueryParams.build(),
            )
    }

    fun _body(): Body = body

    override fun _headers(): Headers = additionalHeaders

    override fun _queryParams(): QueryParams =
        QueryParams.builder()
            .apply {
                put("key", key)
                putAll(additionalQueryParams)
            }
            .build()

    class Body
    private constructor(
        private val driverEmail: JsonField<String>,
        private val steps: JsonField<List<RouteStepsRequest>>,
        private val distance: JsonField<Long>,
        private val documentTemplateId: JsonField<String>,
        private val roRequestId: JsonField<String>,
        private val routing: JsonField<Routing>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("driver_email")
            @ExcludeMissing
            driverEmail: JsonField<String> = JsonMissing.of(),
            @JsonProperty("steps")
            @ExcludeMissing
            steps: JsonField<List<RouteStepsRequest>> = JsonMissing.of(),
            @JsonProperty("distance") @ExcludeMissing distance: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("document_template_id")
            @ExcludeMissing
            documentTemplateId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("ro_request_id")
            @ExcludeMissing
            roRequestId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("routing") @ExcludeMissing routing: JsonField<Routing> = JsonMissing.of(),
        ) : this(
            driverEmail,
            steps,
            distance,
            documentTemplateId,
            roRequestId,
            routing,
            mutableMapOf(),
        )

        /**
         * Specify the e-mail address of the driver who should receive the route. The e-mail address
         * must be registered in [NextBillion.ai Cloud Console](https://console.nextbillion.ai/).
         *
         * @throws NextbillionSdkInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun driverEmail(): String = driverEmail.getRequired("driver_email")

        /**
         * An array of objects to collect the details about the intermediate steps in the route to
         * be dispatched. Each object corresponds to a single step. The array must begin with a
         * start-type step and end with an end-type step, to form a valid route.
         *
         * @throws NextbillionSdkInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun steps(): List<RouteStepsRequest> = steps.getRequired("steps")

        /**
         * Specify the total distance, in meters, for an informative display in Driver's app. The
         * distance specified here has no effect on the actual route that the service generates.
         *
         * @throws NextbillionSdkInvalidDataException if the JSON field has an unexpected type (e.g.
         *   if the server responded with an unexpected value).
         */
        fun distance(): Optional<Long> = distance.getOptional("distance")

        /**
         * Specify the ID of the document template that should be used to collect proof of
         * completion for all steps in the route. In order to complete each route step, the driver
         * will need to submit a form generated by the rules defined in the given document template.
         * Use the [Documents API](https://docs.nextbillion.ai/docs/dispatches/documents-api) to
         * create, read and manage document templates.
         *
         * Please note that the document template ID assigned to a route does not apply to following
         * step types - start, end, break, layover.
         *
         * @throws NextbillionSdkInvalidDataException if the JSON field has an unexpected type (e.g.
         *   if the server responded with an unexpected value).
         */
        fun documentTemplateId(): Optional<String> =
            documentTemplateId.getOptional("document_template_id")

        /**
         * Specify the Route Optimization request ID. When this ID is provided, all other fields
         * will be ignored (including the required fields) and the route optimization result will be
         * used to form the routes and corresponding steps.
         *
         * Please note that:
         * - The driver's email ID must be provided in input vehicle.metadata as user_email such
         *   that the route optimization result must contain a valid driver email, step's arrival
         *   time, etc., to make a successful dispatch.
         * - Document Template for collecting proof of delivery or completion can not be specified
         *   when using this field to dispatch a route.
         * - In case of an error at any part among the routes, the API will immediately return the
         *   error with the index of the specific route or route step.
         * - On a successful dispatch, the API returns the last route, if there are many, in the
         *   response payload.
         *
         * @throws NextbillionSdkInvalidDataException if the JSON field has an unexpected type (e.g.
         *   if the server responded with an unexpected value).
         */
        fun roRequestId(): Optional<String> = roRequestId.getOptional("ro_request_id")

        /**
         * The routing object allows defining the routing characteristics that should be used to
         * generate a route when the Driver uses the in-app navigation. Only car mode is supported
         * currently.
         *
         * @throws NextbillionSdkInvalidDataException if the JSON field has an unexpected type (e.g.
         *   if the server responded with an unexpected value).
         */
        fun routing(): Optional<Routing> = routing.getOptional("routing")

        /**
         * Returns the raw JSON value of [driverEmail].
         *
         * Unlike [driverEmail], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("driver_email")
        @ExcludeMissing
        fun _driverEmail(): JsonField<String> = driverEmail

        /**
         * Returns the raw JSON value of [steps].
         *
         * Unlike [steps], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("steps")
        @ExcludeMissing
        fun _steps(): JsonField<List<RouteStepsRequest>> = steps

        /**
         * Returns the raw JSON value of [distance].
         *
         * Unlike [distance], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("distance") @ExcludeMissing fun _distance(): JsonField<Long> = distance

        /**
         * Returns the raw JSON value of [documentTemplateId].
         *
         * Unlike [documentTemplateId], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("document_template_id")
        @ExcludeMissing
        fun _documentTemplateId(): JsonField<String> = documentTemplateId

        /**
         * Returns the raw JSON value of [roRequestId].
         *
         * Unlike [roRequestId], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("ro_request_id")
        @ExcludeMissing
        fun _roRequestId(): JsonField<String> = roRequestId

        /**
         * Returns the raw JSON value of [routing].
         *
         * Unlike [routing], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("routing") @ExcludeMissing fun _routing(): JsonField<Routing> = routing

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [Body].
             *
             * The following fields are required:
             * ```java
             * .driverEmail()
             * .steps()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [Body]. */
        class Builder internal constructor() {

            private var driverEmail: JsonField<String>? = null
            private var steps: JsonField<MutableList<RouteStepsRequest>>? = null
            private var distance: JsonField<Long> = JsonMissing.of()
            private var documentTemplateId: JsonField<String> = JsonMissing.of()
            private var roRequestId: JsonField<String> = JsonMissing.of()
            private var routing: JsonField<Routing> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(body: Body) = apply {
                driverEmail = body.driverEmail
                steps = body.steps.map { it.toMutableList() }
                distance = body.distance
                documentTemplateId = body.documentTemplateId
                roRequestId = body.roRequestId
                routing = body.routing
                additionalProperties = body.additionalProperties.toMutableMap()
            }

            /**
             * Specify the e-mail address of the driver who should receive the route. The e-mail
             * address must be registered in
             * [NextBillion.ai Cloud Console](https://console.nextbillion.ai/).
             */
            fun driverEmail(driverEmail: String) = driverEmail(JsonField.of(driverEmail))

            /**
             * Sets [Builder.driverEmail] to an arbitrary JSON value.
             *
             * You should usually call [Builder.driverEmail] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun driverEmail(driverEmail: JsonField<String>) = apply {
                this.driverEmail = driverEmail
            }

            /**
             * An array of objects to collect the details about the intermediate steps in the route
             * to be dispatched. Each object corresponds to a single step. The array must begin with
             * a start-type step and end with an end-type step, to form a valid route.
             */
            fun steps(steps: List<RouteStepsRequest>) = steps(JsonField.of(steps))

            /**
             * Sets [Builder.steps] to an arbitrary JSON value.
             *
             * You should usually call [Builder.steps] with a well-typed `List<RouteStepsRequest>`
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun steps(steps: JsonField<List<RouteStepsRequest>>) = apply {
                this.steps = steps.map { it.toMutableList() }
            }

            /**
             * Adds a single [RouteStepsRequest] to [steps].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addStep(step: RouteStepsRequest) = apply {
                steps =
                    (steps ?: JsonField.of(mutableListOf())).also {
                        checkKnown("steps", it).add(step)
                    }
            }

            /**
             * Specify the total distance, in meters, for an informative display in Driver's app.
             * The distance specified here has no effect on the actual route that the service
             * generates.
             */
            fun distance(distance: Long) = distance(JsonField.of(distance))

            /**
             * Sets [Builder.distance] to an arbitrary JSON value.
             *
             * You should usually call [Builder.distance] with a well-typed [Long] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun distance(distance: JsonField<Long>) = apply { this.distance = distance }

            /**
             * Specify the ID of the document template that should be used to collect proof of
             * completion for all steps in the route. In order to complete each route step, the
             * driver will need to submit a form generated by the rules defined in the given
             * document template. Use the
             * [Documents API](https://docs.nextbillion.ai/docs/dispatches/documents-api) to create,
             * read and manage document templates.
             *
             * Please note that the document template ID assigned to a route does not apply to
             * following step types - start, end, break, layover.
             */
            fun documentTemplateId(documentTemplateId: String) =
                documentTemplateId(JsonField.of(documentTemplateId))

            /**
             * Sets [Builder.documentTemplateId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.documentTemplateId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun documentTemplateId(documentTemplateId: JsonField<String>) = apply {
                this.documentTemplateId = documentTemplateId
            }

            /**
             * Specify the Route Optimization request ID. When this ID is provided, all other fields
             * will be ignored (including the required fields) and the route optimization result
             * will be used to form the routes and corresponding steps.
             *
             * Please note that:
             * - The driver's email ID must be provided in input vehicle.metadata as user_email such
             *   that the route optimization result must contain a valid driver email, step's
             *   arrival time, etc., to make a successful dispatch.
             * - Document Template for collecting proof of delivery or completion can not be
             *   specified when using this field to dispatch a route.
             * - In case of an error at any part among the routes, the API will immediately return
             *   the error with the index of the specific route or route step.
             * - On a successful dispatch, the API returns the last route, if there are many, in the
             *   response payload.
             */
            fun roRequestId(roRequestId: String) = roRequestId(JsonField.of(roRequestId))

            /**
             * Sets [Builder.roRequestId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.roRequestId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun roRequestId(roRequestId: JsonField<String>) = apply {
                this.roRequestId = roRequestId
            }

            /**
             * The routing object allows defining the routing characteristics that should be used to
             * generate a route when the Driver uses the in-app navigation. Only car mode is
             * supported currently.
             */
            fun routing(routing: Routing) = routing(JsonField.of(routing))

            /**
             * Sets [Builder.routing] to an arbitrary JSON value.
             *
             * You should usually call [Builder.routing] with a well-typed [Routing] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun routing(routing: JsonField<Routing>) = apply { this.routing = routing }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [Body].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .driverEmail()
             * .steps()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): Body =
                Body(
                    checkRequired("driverEmail", driverEmail),
                    checkRequired("steps", steps).map { it.toImmutable() },
                    distance,
                    documentTemplateId,
                    roRequestId,
                    routing,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): Body = apply {
            if (validated) {
                return@apply
            }

            driverEmail()
            steps().forEach { it.validate() }
            distance()
            documentTemplateId()
            roRequestId()
            routing().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: NextbillionSdkInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (driverEmail.asKnown().isPresent) 1 else 0) +
                (steps.asKnown().getOrNull()?.sumOf { it.validity().toInt() } ?: 0) +
                (if (distance.asKnown().isPresent) 1 else 0) +
                (if (documentTemplateId.asKnown().isPresent) 1 else 0) +
                (if (roRequestId.asKnown().isPresent) 1 else 0) +
                (routing.asKnown().getOrNull()?.validity() ?: 0)

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is Body &&
                driverEmail == other.driverEmail &&
                steps == other.steps &&
                distance == other.distance &&
                documentTemplateId == other.documentTemplateId &&
                roRequestId == other.roRequestId &&
                routing == other.routing &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                driverEmail,
                steps,
                distance,
                documentTemplateId,
                roRequestId,
                routing,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "Body{driverEmail=$driverEmail, steps=$steps, distance=$distance, documentTemplateId=$documentTemplateId, roRequestId=$roRequestId, routing=$routing, additionalProperties=$additionalProperties}"
    }

    /**
     * The routing object allows defining the routing characteristics that should be used to
     * generate a route when the Driver uses the in-app navigation. Only car mode is supported
     * currently.
     */
    class Routing
    private constructor(
        private val approaches: JsonField<Approaches>,
        private val avoid: JsonField<Avoid>,
        private val hazmatType: JsonField<HazmatType>,
        private val mode: JsonField<Mode>,
        private val truckAxleLoad: JsonField<Long>,
        private val truckSize: JsonField<String>,
        private val truckWeight: JsonField<Long>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("approaches")
            @ExcludeMissing
            approaches: JsonField<Approaches> = JsonMissing.of(),
            @JsonProperty("avoid") @ExcludeMissing avoid: JsonField<Avoid> = JsonMissing.of(),
            @JsonProperty("hazmat_type")
            @ExcludeMissing
            hazmatType: JsonField<HazmatType> = JsonMissing.of(),
            @JsonProperty("mode") @ExcludeMissing mode: JsonField<Mode> = JsonMissing.of(),
            @JsonProperty("truck_axle_load")
            @ExcludeMissing
            truckAxleLoad: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("truck_size")
            @ExcludeMissing
            truckSize: JsonField<String> = JsonMissing.of(),
            @JsonProperty("truck_weight")
            @ExcludeMissing
            truckWeight: JsonField<Long> = JsonMissing.of(),
        ) : this(
            approaches,
            avoid,
            hazmatType,
            mode,
            truckAxleLoad,
            truckSize,
            truckWeight,
            mutableMapOf(),
        )

        /**
         * Specify the side of the road from which the route should approach the step location. When
         * set to unrestricted a route can arrive at the step location from either side of the road
         * and when set to curb the route will arrive at the step location only from the driving
         * side of the region. Use a semi-colon ; to specify approach configurations for multiple
         * steps.
         *
         * @throws NextbillionSdkInvalidDataException if the JSON field has an unexpected type (e.g.
         *   if the server responded with an unexpected value).
         */
        fun approaches(): Optional<Approaches> = approaches.getOptional("approaches")

        /**
         * Setting this will ensure the generated route avoids the object(s) specified in the input.
         * Multiple values should be separated by a pipe (|). If none is provided along with other
         * values, an error is returned as a valid route is not feasible.
         *
         * @throws NextbillionSdkInvalidDataException if the JSON field has an unexpected type (e.g.
         *   if the server responded with an unexpected value).
         */
        fun avoid(): Optional<Avoid> = avoid.getOptional("avoid")

        /**
         * Specify the type of hazardous material being carried and the dispatch service will avoid
         * roads which are not suitable for the type of goods specified. Multiple values can be
         * separated using a pipe operator | .
         *
         * Please note that this parameter is effective only when mode=truck.
         *
         * @throws NextbillionSdkInvalidDataException if the JSON field has an unexpected type (e.g.
         *   if the server responded with an unexpected value).
         */
        fun hazmatType(): Optional<HazmatType> = hazmatType.getOptional("hazmat_type")

        /**
         * Specify the driving mode that the service should use to determine a route
         *
         * @throws NextbillionSdkInvalidDataException if the JSON field has an unexpected type (e.g.
         *   if the server responded with an unexpected value).
         */
        fun mode(): Optional<Mode> = mode.getOptional("mode")

        /**
         * Specify the total load per axle (including the weight of trailers and shipped goods) of
         * the truck, in tonnes. When specified, the dispatched route uses only those roads which
         * can be used by a truck to carry the specified load per axle.
         *
         * Please note this parameter is effective only when mode=truck.
         *
         * @throws NextbillionSdkInvalidDataException if the JSON field has an unexpected type (e.g.
         *   if the server responded with an unexpected value).
         */
        fun truckAxleLoad(): Optional<Long> = truckAxleLoad.getOptional("truck_axle_load")

        /**
         * Specify the dimensions of a truck, in centimeters (cm), in the format of <height, width,
         * length>. When specified, the dispatched route uses only those roads which allow trucks
         * with specified dimensions.
         *
         * Please note this parameter is effective only when mode=truck. Also, the maximum
         * dimensions that can be specified are as follows:
         *
         * Height = 1000 cm Width = 5000 cm Length = 5000 cm
         *
         * @throws NextbillionSdkInvalidDataException if the JSON field has an unexpected type (e.g.
         *   if the server responded with an unexpected value).
         */
        fun truckSize(): Optional<String> = truckSize.getOptional("truck_size")

        /**
         * Specify the weight of the truck, including trailers and shipped goods, in kilograms (kg).
         * When specified, the dispatched route uses only those roads which allow trucks with
         * specified weight.
         *
         * Please note this parameter is effective only when mode=truck. Also, the maximum weight
         * that can be specified for a truck is 100,000 kgs.
         *
         * @throws NextbillionSdkInvalidDataException if the JSON field has an unexpected type (e.g.
         *   if the server responded with an unexpected value).
         */
        fun truckWeight(): Optional<Long> = truckWeight.getOptional("truck_weight")

        /**
         * Returns the raw JSON value of [approaches].
         *
         * Unlike [approaches], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("approaches")
        @ExcludeMissing
        fun _approaches(): JsonField<Approaches> = approaches

        /**
         * Returns the raw JSON value of [avoid].
         *
         * Unlike [avoid], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("avoid") @ExcludeMissing fun _avoid(): JsonField<Avoid> = avoid

        /**
         * Returns the raw JSON value of [hazmatType].
         *
         * Unlike [hazmatType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("hazmat_type")
        @ExcludeMissing
        fun _hazmatType(): JsonField<HazmatType> = hazmatType

        /**
         * Returns the raw JSON value of [mode].
         *
         * Unlike [mode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("mode") @ExcludeMissing fun _mode(): JsonField<Mode> = mode

        /**
         * Returns the raw JSON value of [truckAxleLoad].
         *
         * Unlike [truckAxleLoad], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("truck_axle_load")
        @ExcludeMissing
        fun _truckAxleLoad(): JsonField<Long> = truckAxleLoad

        /**
         * Returns the raw JSON value of [truckSize].
         *
         * Unlike [truckSize], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("truck_size") @ExcludeMissing fun _truckSize(): JsonField<String> = truckSize

        /**
         * Returns the raw JSON value of [truckWeight].
         *
         * Unlike [truckWeight], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("truck_weight")
        @ExcludeMissing
        fun _truckWeight(): JsonField<Long> = truckWeight

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /** Returns a mutable builder for constructing an instance of [Routing]. */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [Routing]. */
        class Builder internal constructor() {

            private var approaches: JsonField<Approaches> = JsonMissing.of()
            private var avoid: JsonField<Avoid> = JsonMissing.of()
            private var hazmatType: JsonField<HazmatType> = JsonMissing.of()
            private var mode: JsonField<Mode> = JsonMissing.of()
            private var truckAxleLoad: JsonField<Long> = JsonMissing.of()
            private var truckSize: JsonField<String> = JsonMissing.of()
            private var truckWeight: JsonField<Long> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(routing: Routing) = apply {
                approaches = routing.approaches
                avoid = routing.avoid
                hazmatType = routing.hazmatType
                mode = routing.mode
                truckAxleLoad = routing.truckAxleLoad
                truckSize = routing.truckSize
                truckWeight = routing.truckWeight
                additionalProperties = routing.additionalProperties.toMutableMap()
            }

            /**
             * Specify the side of the road from which the route should approach the step location.
             * When set to unrestricted a route can arrive at the step location from either side of
             * the road and when set to curb the route will arrive at the step location only from
             * the driving side of the region. Use a semi-colon ; to specify approach configurations
             * for multiple steps.
             */
            fun approaches(approaches: Approaches) = approaches(JsonField.of(approaches))

            /**
             * Sets [Builder.approaches] to an arbitrary JSON value.
             *
             * You should usually call [Builder.approaches] with a well-typed [Approaches] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun approaches(approaches: JsonField<Approaches>) = apply {
                this.approaches = approaches
            }

            /**
             * Setting this will ensure the generated route avoids the object(s) specified in the
             * input. Multiple values should be separated by a pipe (|). If none is provided along
             * with other values, an error is returned as a valid route is not feasible.
             */
            fun avoid(avoid: Avoid) = avoid(JsonField.of(avoid))

            /**
             * Sets [Builder.avoid] to an arbitrary JSON value.
             *
             * You should usually call [Builder.avoid] with a well-typed [Avoid] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun avoid(avoid: JsonField<Avoid>) = apply { this.avoid = avoid }

            /**
             * Specify the type of hazardous material being carried and the dispatch service will
             * avoid roads which are not suitable for the type of goods specified. Multiple values
             * can be separated using a pipe operator | .
             *
             * Please note that this parameter is effective only when mode=truck.
             */
            fun hazmatType(hazmatType: HazmatType) = hazmatType(JsonField.of(hazmatType))

            /**
             * Sets [Builder.hazmatType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.hazmatType] with a well-typed [HazmatType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun hazmatType(hazmatType: JsonField<HazmatType>) = apply {
                this.hazmatType = hazmatType
            }

            /** Specify the driving mode that the service should use to determine a route */
            fun mode(mode: Mode) = mode(JsonField.of(mode))

            /**
             * Sets [Builder.mode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.mode] with a well-typed [Mode] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun mode(mode: JsonField<Mode>) = apply { this.mode = mode }

            /**
             * Specify the total load per axle (including the weight of trailers and shipped goods)
             * of the truck, in tonnes. When specified, the dispatched route uses only those roads
             * which can be used by a truck to carry the specified load per axle.
             *
             * Please note this parameter is effective only when mode=truck.
             */
            fun truckAxleLoad(truckAxleLoad: Long) = truckAxleLoad(JsonField.of(truckAxleLoad))

            /**
             * Sets [Builder.truckAxleLoad] to an arbitrary JSON value.
             *
             * You should usually call [Builder.truckAxleLoad] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun truckAxleLoad(truckAxleLoad: JsonField<Long>) = apply {
                this.truckAxleLoad = truckAxleLoad
            }

            /**
             * Specify the dimensions of a truck, in centimeters (cm), in the format of <height,
             * width, length>. When specified, the dispatched route uses only those roads which
             * allow trucks with specified dimensions.
             *
             * Please note this parameter is effective only when mode=truck. Also, the maximum
             * dimensions that can be specified are as follows:
             *
             * Height = 1000 cm Width = 5000 cm Length = 5000 cm
             */
            fun truckSize(truckSize: String) = truckSize(JsonField.of(truckSize))

            /**
             * Sets [Builder.truckSize] to an arbitrary JSON value.
             *
             * You should usually call [Builder.truckSize] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun truckSize(truckSize: JsonField<String>) = apply { this.truckSize = truckSize }

            /**
             * Specify the weight of the truck, including trailers and shipped goods, in kilograms
             * (kg). When specified, the dispatched route uses only those roads which allow trucks
             * with specified weight.
             *
             * Please note this parameter is effective only when mode=truck. Also, the maximum
             * weight that can be specified for a truck is 100,000 kgs.
             */
            fun truckWeight(truckWeight: Long) = truckWeight(JsonField.of(truckWeight))

            /**
             * Sets [Builder.truckWeight] to an arbitrary JSON value.
             *
             * You should usually call [Builder.truckWeight] with a well-typed [Long] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun truckWeight(truckWeight: JsonField<Long>) = apply { this.truckWeight = truckWeight }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [Routing].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             */
            fun build(): Routing =
                Routing(
                    approaches,
                    avoid,
                    hazmatType,
                    mode,
                    truckAxleLoad,
                    truckSize,
                    truckWeight,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): Routing = apply {
            if (validated) {
                return@apply
            }

            approaches().ifPresent { it.validate() }
            avoid().ifPresent { it.validate() }
            hazmatType().ifPresent { it.validate() }
            mode().ifPresent { it.validate() }
            truckAxleLoad()
            truckSize()
            truckWeight()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: NextbillionSdkInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (approaches.asKnown().getOrNull()?.validity() ?: 0) +
                (avoid.asKnown().getOrNull()?.validity() ?: 0) +
                (hazmatType.asKnown().getOrNull()?.validity() ?: 0) +
                (mode.asKnown().getOrNull()?.validity() ?: 0) +
                (if (truckAxleLoad.asKnown().isPresent) 1 else 0) +
                (if (truckSize.asKnown().isPresent) 1 else 0) +
                (if (truckWeight.asKnown().isPresent) 1 else 0)

        /**
         * Specify the side of the road from which the route should approach the step location. When
         * set to unrestricted a route can arrive at the step location from either side of the road
         * and when set to curb the route will arrive at the step location only from the driving
         * side of the region. Use a semi-colon ; to specify approach configurations for multiple
         * steps.
         */
        class Approaches @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val UNRESTRICTED = of("unrestricted")

                @JvmField val CURB = of("curb")

                @JvmStatic fun of(value: String) = Approaches(JsonField.of(value))
            }

            /** An enum containing [Approaches]'s known values. */
            enum class Known {
                UNRESTRICTED,
                CURB,
            }

            /**
             * An enum containing [Approaches]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Approaches] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                UNRESTRICTED,
                CURB,
                /**
                 * An enum member indicating that [Approaches] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    UNRESTRICTED -> Value.UNRESTRICTED
                    CURB -> Value.CURB
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws NextbillionSdkInvalidDataException if this class instance's value is a not a
             *   known member.
             */
            fun known(): Known =
                when (this) {
                    UNRESTRICTED -> Known.UNRESTRICTED
                    CURB -> Known.CURB
                    else -> throw NextbillionSdkInvalidDataException("Unknown Approaches: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws NextbillionSdkInvalidDataException if this class instance's value does not
             *   have the expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow {
                    NextbillionSdkInvalidDataException("Value is not a String")
                }

            private var validated: Boolean = false

            fun validate(): Approaches = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: NextbillionSdkInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Approaches && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * Setting this will ensure the generated route avoids the object(s) specified in the input.
         * Multiple values should be separated by a pipe (|). If none is provided along with other
         * values, an error is returned as a valid route is not feasible.
         */
        class Avoid @JsonCreator private constructor(private val value: JsonField<String>) : Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TOLL = of("toll")

                @JvmField val HIGHWAY = of("highway")

                @JvmField val FERRY = of("ferry")

                @JvmField val SHARP_TURN = of("sharp_turn")

                @JvmField val UTURN = of("uturn")

                @JvmField val LEFT_TURN = of("left_turn")

                @JvmField val RIGHT_TURN = of("right_turn")

                @JvmField val SERVICE_ROAD = of("service_road")

                @JvmField val NONE = of("none")

                @JvmStatic fun of(value: String) = Avoid(JsonField.of(value))
            }

            /** An enum containing [Avoid]'s known values. */
            enum class Known {
                TOLL,
                HIGHWAY,
                FERRY,
                SHARP_TURN,
                UTURN,
                LEFT_TURN,
                RIGHT_TURN,
                SERVICE_ROAD,
                NONE,
            }

            /**
             * An enum containing [Avoid]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Avoid] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                TOLL,
                HIGHWAY,
                FERRY,
                SHARP_TURN,
                UTURN,
                LEFT_TURN,
                RIGHT_TURN,
                SERVICE_ROAD,
                NONE,
                /**
                 * An enum member indicating that [Avoid] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    TOLL -> Value.TOLL
                    HIGHWAY -> Value.HIGHWAY
                    FERRY -> Value.FERRY
                    SHARP_TURN -> Value.SHARP_TURN
                    UTURN -> Value.UTURN
                    LEFT_TURN -> Value.LEFT_TURN
                    RIGHT_TURN -> Value.RIGHT_TURN
                    SERVICE_ROAD -> Value.SERVICE_ROAD
                    NONE -> Value.NONE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws NextbillionSdkInvalidDataException if this class instance's value is a not a
             *   known member.
             */
            fun known(): Known =
                when (this) {
                    TOLL -> Known.TOLL
                    HIGHWAY -> Known.HIGHWAY
                    FERRY -> Known.FERRY
                    SHARP_TURN -> Known.SHARP_TURN
                    UTURN -> Known.UTURN
                    LEFT_TURN -> Known.LEFT_TURN
                    RIGHT_TURN -> Known.RIGHT_TURN
                    SERVICE_ROAD -> Known.SERVICE_ROAD
                    NONE -> Known.NONE
                    else -> throw NextbillionSdkInvalidDataException("Unknown Avoid: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws NextbillionSdkInvalidDataException if this class instance's value does not
             *   have the expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow {
                    NextbillionSdkInvalidDataException("Value is not a String")
                }

            private var validated: Boolean = false

            fun validate(): Avoid = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: NextbillionSdkInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Avoid && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * Specify the type of hazardous material being carried and the dispatch service will avoid
         * roads which are not suitable for the type of goods specified. Multiple values can be
         * separated using a pipe operator | .
         *
         * Please note that this parameter is effective only when mode=truck.
         */
        class HazmatType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val GENERAL = of("general")

                @JvmField val CIRCUMSTANTIAL = of("circumstantial")

                @JvmField val EXPLOSIVE = of("explosive")

                @JvmField val HARMFUL_TO_WATER = of("harmful_to_water")

                @JvmStatic fun of(value: String) = HazmatType(JsonField.of(value))
            }

            /** An enum containing [HazmatType]'s known values. */
            enum class Known {
                GENERAL,
                CIRCUMSTANTIAL,
                EXPLOSIVE,
                HARMFUL_TO_WATER,
            }

            /**
             * An enum containing [HazmatType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [HazmatType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                GENERAL,
                CIRCUMSTANTIAL,
                EXPLOSIVE,
                HARMFUL_TO_WATER,
                /**
                 * An enum member indicating that [HazmatType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    GENERAL -> Value.GENERAL
                    CIRCUMSTANTIAL -> Value.CIRCUMSTANTIAL
                    EXPLOSIVE -> Value.EXPLOSIVE
                    HARMFUL_TO_WATER -> Value.HARMFUL_TO_WATER
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws NextbillionSdkInvalidDataException if this class instance's value is a not a
             *   known member.
             */
            fun known(): Known =
                when (this) {
                    GENERAL -> Known.GENERAL
                    CIRCUMSTANTIAL -> Known.CIRCUMSTANTIAL
                    EXPLOSIVE -> Known.EXPLOSIVE
                    HARMFUL_TO_WATER -> Known.HARMFUL_TO_WATER
                    else -> throw NextbillionSdkInvalidDataException("Unknown HazmatType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws NextbillionSdkInvalidDataException if this class instance's value does not
             *   have the expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow {
                    NextbillionSdkInvalidDataException("Value is not a String")
                }

            private var validated: Boolean = false

            fun validate(): HazmatType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: NextbillionSdkInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is HazmatType && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /** Specify the driving mode that the service should use to determine a route */
        class Mode @JsonCreator private constructor(private val value: JsonField<String>) : Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val CAR = of("car")

                @JvmStatic fun of(value: String) = Mode(JsonField.of(value))
            }

            /** An enum containing [Mode]'s known values. */
            enum class Known {
                CAR
            }

            /**
             * An enum containing [Mode]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Mode] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                CAR,
                /** An enum member indicating that [Mode] was instantiated with an unknown value. */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    CAR -> Value.CAR
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws NextbillionSdkInvalidDataException if this class instance's value is a not a
             *   known member.
             */
            fun known(): Known =
                when (this) {
                    CAR -> Known.CAR
                    else -> throw NextbillionSdkInvalidDataException("Unknown Mode: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws NextbillionSdkInvalidDataException if this class instance's value does not
             *   have the expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow {
                    NextbillionSdkInvalidDataException("Value is not a String")
                }

            private var validated: Boolean = false

            fun validate(): Mode = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: NextbillionSdkInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return other is Mode && value == other.value
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is Routing &&
                approaches == other.approaches &&
                avoid == other.avoid &&
                hazmatType == other.hazmatType &&
                mode == other.mode &&
                truckAxleLoad == other.truckAxleLoad &&
                truckSize == other.truckSize &&
                truckWeight == other.truckWeight &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                approaches,
                avoid,
                hazmatType,
                mode,
                truckAxleLoad,
                truckSize,
                truckWeight,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "Routing{approaches=$approaches, avoid=$avoid, hazmatType=$hazmatType, mode=$mode, truckAxleLoad=$truckAxleLoad, truckSize=$truckSize, truckWeight=$truckWeight, additionalProperties=$additionalProperties}"
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) {
            return true
        }

        return other is RouteCreateParams &&
            key == other.key &&
            body == other.body &&
            additionalHeaders == other.additionalHeaders &&
            additionalQueryParams == other.additionalQueryParams
    }

    override fun hashCode(): Int = Objects.hash(key, body, additionalHeaders, additionalQueryParams)

    override fun toString() =
        "RouteCreateParams{key=$key, body=$body, additionalHeaders=$additionalHeaders, additionalQueryParams=$additionalQueryParams}"
}
